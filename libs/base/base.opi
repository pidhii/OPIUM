load "base.so";

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Miscelenious
#
let swap f (x, y) = f (y, x);

let flip f =
  let aux1 xs =
    let aux2 ys = apply (apply (f, ys), xs)
    in aux2 . list
  in aux1 . list;

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Iteration
#
trait reverse (self) =
  let rec loop (l, acc) =
    unless let x:xs = next l then acc
    else loop (xs, x:acc)
  in loop (self, nil);

trait foreach (self, f) =
  let rec loop l =
    unless let x:xs = next l then nil
    else { f x; loop xs }
  in loop self;
let foreach l f = foreach (l, f);

trait foldl (self, f, z) =
  let rec fold (l, acc) =
    unless let x:xs = next l then acc
    else fold (xs, f (acc, x))
  in fold (self, z);
let foldl f z xs = foldl (xs, f, z);

trait foldr (self, f, z) = foldl (swap f) z (reverse self);
let foldr f z l = foldr (l, f, z);

impl lazy length (self) =
  let rec loop (it, acc) =
    unless let x:xs = !it then acc
    else loop (xs, acc + 1)
  in loop (self, 0);

let rec range from to =
  if from >= to then nil
  else @from : range (from + 1) to;

let rec map f l =
  unless let x:xs = next l then nil
  else @f x : map f xs;

# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# Consumers
#
trait tostring (self) = format ("%d", self);
impl string tostring (self) = self;
impl blob tostring (self) = __blob_to_string self;

trait tolist (self) = foldr (:) nil self;
impl null tolist (self) = nil;
impl pair tolist (self) = self;

